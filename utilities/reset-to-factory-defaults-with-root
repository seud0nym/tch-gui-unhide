#!/bin/sh

SCRIPT="$(basename $0)"

GREEN='\033[1;32m'
GREY='\033[90m'
ORANGE='\033[0;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

VERSION="$(uci get version.@version[0].marketing_version)"
SERIAL=$(uci get env.var.serial)
LAN_IP_NOW="$(ip -o -4 address show dev br-lan | grep -oE '[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+' | head -n1)"
OVERLAY_FS="$(mount | grep '/overlay type' | cut -d' ' -f5)"
ROM_FS="$(mount | grep '/rom type' | cut -d' ' -f5)"
MOUNT_PATH="$(uci get mountd.mountd.path)"
USB="$(ls $MOUNT_PATH | head -n1)"
UCI_DEFAULTS="zzz-9999-reroot"
BOOTMGR="$(which bootmgr)"
LSOF="$(which lsof)"

VARIANT=$(uci -q get env.var.variant_friendly_name | sed -e 's/TLS//')
[ -z "$VARIANT" ] && VARIANT=$(uci -q get env.var.prod_friendly_name | sed -e 's/Technicolor //' -e 's/TLS//')
MAC_HEX=$(uci -q get env.var.ssid_mac_postfix_r0)

if [ -z "$BOOTMGR" ]; then
  ACTIVE="$(cat /proc/banktable/active 2>/dev/null)"
  BOOTED="$(cat /proc/banktable/booted 2>/dev/null)"
  NOT_BOOTED="$(cat /proc/banktable/notbooted 2>/dev/null)"
else
  ACTIVE="bank_$($BOOTMGR partition active | grep -v rd_metadata)"
  BOOTED="bank_$($BOOTMGR partition booted)"
  NOT_BOOTED="bank_$($BOOTMGR partition notbooted)"
fi
[ $BOOTED = bank_1 ] && PASSIVE=2 || PASSIVE=1

#region usage()
check_location() {
  if [ -n "$LSOF" ]; then
    if $LSOF /overlay | grep -qE "\b$$\b|$SCRIPT"; then
      echo -e "${RED}ERROR:    You CANNOT run this script from this location!${NC}"
      echo "          Copy it to /tmp or USB and run from there. e.g."
      echo -e "${GREY}"
      echo "cp -p $SCRIPT /tmp"
      echo "cd /tmp"
      echo "sh $SCRIPT $*"
      echo -e "${NC}"
      exit 2
    fi
  fi
}

usage() {
cat <<EOH
Resets the device to factory defaults, and prepares a run-once root access
setup script to be executed on the next boot.

It is basically the same as the procedure as described in
http://hack-technicolor.rtfd.io/en/stable/Upgrade/#preserving-root-access,
but with some additional options.

Usage: $0 [options]

Options:
 -b                 Make a full backup of your configuration from /overlay
                      before resetting to factory defaults.
                     (Requires attached USB device).
 -B                 Configure for bridged mode. Implies --no-forwards, 
                      --no-leases and --no-ula. Ignored if --restore-config
                      is specified.
 -c                 Disable CWMP configuration during first boot after reset.
 -C                 Disable reboot on core dump after reset.
 -d                 Add DNS rewrites to disable CWMP firmware downloads from
                      fwstore.bdms.telstra.net
 -D domain          Add DNS rewrites to disable CWMP firmware downloads from
                      the specified domain. May be specified multiple times.
 -e                 Disable any 'noexec' flags on USB mounted filesystems.
 -f filename        Flashes the specified firmware 'filename' before reset and 
                      reboot. If 'filename' ends with .rbi, it will be unpacked 
                      first, either to an attached USB device, or /tmp if no USB 
                      is detected. 
                      - If 'filename' ends in .rbi or .bin, it will be flashed 
                        into the booted bank, unless -s is specified.
                      - If 'filename' ends with .pkgtb, the firmware will be 
                        flashed into the passive bank using sysupgrade (root 
                        access will be preserved) and banks will be switched on 
                        reboot.
 -h d|n|s|hostname  Sets the device hostname, where:
                      d = Set the hostname to $VARIANT
                      n = Set the hostname to $HOSTNAME
                      s = Set the hostname to $VARIANT-$MAC_HEX
                      hostname = Use the specified hostname
 -i                 Keep the existing LAN IP address after reset and reboot.
                      This is the default if --restore-config is specified.
                      By default, also restores port forwards, static leases
                      and the IPv6 ULA and prefix size (unless --no-forwards, 
                      --no-leases or --no-ula are specified).
 -I n.n.n.n|DHCP    Use IP address n.n.n.n OR obtain the IP address from DHCP
                      after reset and reboot
 -k                 Keep existing SSH keys after reset and reboot.
 -l n.n.n.n:port    Configure logging to a remote syslog server on the specified
                      IP address and port. The port is optional and defaults to
                      514 if not specified.
 -m                 Keep existing mobile operators and profiles, and linked 
                      WWAN profile.
                      Ignored if no mobile profiles found.
 -n                 Do NOT reboot.
 -p password        Set the password after reset and reboot. If not specified,
                      it defaults to root.
 -s                 Apply factory reset and acquire root on the passive bank, 
                      rather than the booted bank, and then switch banks after 
                      reboot. Firmware will also be flashed into the passive 
                      bank. This is the default when flashing a .pkgtb firmware 
                      into the passive bank.
 -v                 Show the reset script after it has been written.
 -y                 Bypass confirmation prompt (answers 'y').
 --force-backup     By default, attempting to overwrite a backup created today
                      will cause the script to abort. Specify this option to
                      force a new backup to overwrite the previous backup.
 --no-bank-check    Bypass adding the login notification about whether the bank
                      plan is optimal or not.
 --no-keys-check    Bypass check for updated authorized_keys file.
                      By default if -k is specified, and an authorized_keys file
                      exists in the current directory, and the default
                      authorized_keys has not been updated, then the local
                      authorized_keys file will be restored instead of the 
                      current /etc/dropbear/authorized_keys.
 --no-forwards      Bypass restore of port forwards (ignored unless -i is
                      specified).
 --no-leases        Bypass restore of static leases (ignored unless -i is
                      specified).
 --no-rc.local      Bypass restore of /etc/rc.local.
 --no-sms-db        Bypass restore of the SMS message database.
 --no-ula           Bypass restore of the IPv6 ULA and LAN prefix size (ignored 
                      unless -i is specified).
 --save-defaults    Saves the command line options (except -f/-s/-y) as defaults.
                      When specified, NO changes are applied to the device.
 --show-defaults    Shows the settings that would be applied (defaults and over-rides)
                      When specified, NO changes are applied to the device.
 --no-backup        Ignore the -b option if a backup was already taken today.
 --no-defaults      Ignores any saved defaults for this execution
                      --no-defaults must be the FIRST option specified.
 -U                 Download the latest version of $SCRIPT from GitHub.
                      Do NOT specify any other parameters or options if doing
                      a version upgrade.
 --restore-config   Runs the restore-config.sh script after reboot if it is found
                      in the USB backups directory. Output will be written to the 
                      system log. --restore-config should be the LAST option
                      specified, and may optionally be followed by the name of
                      the overlay backup file to be restored. Saved defaults are
                      IGNORED when --restore-config is specified.
 --i                Specifies that the IP address configured by the -i or -I options 
                      is also to be applied after the configuration is restored. If
                      not specified, the IP address used will be the one found in the 
                      configuration backup. Ignored unless --restore-config is also 
                      specified.
EOH
echo
check_location
exit
}
#endregion

comparable_version() {
  local result=""
  local portion
  local number
  local count=0
  for portion in $(echo $1 | tr '.' ' '); do
    count=$((count+1))
    if echo $portion | grep -q [0-9]; then
      number=$(( $portion + 0 ))
      if [ ${#number} -le 2 ]; then
        result="${result}$(printf "%02d" "$number")"
      else
        result="${result}$(printf "%04d" "$number")"
      fi
    else
      result="${result}$(echo -n $portion | hexdump -e '1/1 "%03d"')"
    fi
  done
  [ $count -lt 3 ] && result="${result}000"
  echo $result
}

#region rtfd_script()
rtfd_script() {
# Based on https://hack-technicolor.readthedocs.io/en/stable/Upgrade/#preserving-root-access
cat <<END
#!/bin/sh
exec 1>/tmp/${UCI_DEFAULTS}.out 2>/tmp/${UCI_DEFAULTS}.err
echo root:$__ROOTPWD | chpasswd
sed -i 's#/root:.*\$#/root:/bin/ash#' /etc/passwd
sed -i -e 's/#//' -e 's#askconsole:.*\$#askconsole:/bin/ash#' /etc/inittab
for r in \$(uci show firewall | grep "dest_port='22'" | cut -d. -f1-2); do 
  [ "\$(uci -q get \$r.target)" = DROP -a "\$(uci -q get \$r.src)" = lan -a -z "\$(uci -q get \$r.dest)" ] && uci -q set \$r.target='ACCEPT'
done
if [ -z "\$(uci -q get dropbear.lan)" ]; then
  uci add dropbear dropbear
  uci rename dropbear.@dropbear[-1]=lan
fi
uci set dropbear.lan.enable='1'
uci set dropbear.lan.Interface='lan'
uci set dropbear.lan.Port='22'
uci set dropbear.lan.IdleTimeout='600'
uci set dropbear.lan.PasswordAuth='on'
uci set dropbear.lan.RootPasswordAuth='on'
uci set dropbear.lan.RootLogin='1'
/etc/init.d/dropbear enable
END
[ -n "$BRIDGE_CFG" ]   && echo "$BRIDGE_CFG"
[ -n "$LAN_CFG" ]      && echo "$LAN_CFG"
[ -n "$CWMP_CFG" ]     && echo "$CWMP_CFG"
[ -n "$SYS_CFG" ]      && echo "$SYS_CFG"
[ -n "$DNSMASQ_CFG" ]  && echo "$DNSMASQ_CFG"
[ -n "$HOSTNAME_CFG" ] && echo "$HOSTNAME_CFG"
[ -n "$SYSLOG_CFG" ]   && echo "$SYSLOG_CFG"
[ -n "$NOEXEC_CFG" ]   && echo "$NOEXEC_CFG"
[ -n "$KEYS_CFG" ]     && echo "$KEYS_CFG"
[ -n "$SMSDB_CFG" ]    && echo "$SMSDB_CFG"
[ -n "$RC_LOCAL_CFG" ] && echo "$RC_LOCAL_CFG"
[ -n "$MOBILED_CFG" ]  && echo "$MOBILED_CFG"
[ -n "$RESTORE_CFG" ]  && echo "$RESTORE_CFG"
[ -n "$BOOTMGR" -a "$SWITCH_BANK" = "Y" ] && echo "bootmgr switch_over $PASSIVE"
[ "$__NO_BANK_PLAN_CHK" = "N" ] && cat <<"END"
if [ -d /etc/profile.d ]; then
  __PROFILE=/etc/profile.d/show-bank-plan.sh
  touch $__PROFILE
  chmod +x $__PROFILE
  echo '#!/bin/sh'>$__PROFILE
else
  __PROFILE=/etc/profile
fi
cat <<"PROFILE">>$__PROFILE
if [ -d /proc/banktable ]; then
  ACTIVE_OPTIMAL="1"
  ACTIVE="$(cat /proc/banktable/active | cut -c6)"
  BOOTED="$(cat /proc/banktable/booted | cut -c6)"
else
  ACTIVE_OPTIMAL="2"
  ACTIVE="$(bootmgr partition active 2>/dev/null | grep -v rd_metadata)"
  BOOTED="$(bootmgr partition booted 2>/dev/null | grep -v rd_metadata)"
fi
if [ "$ACTIVE" = "$ACTIVE_OPTIMAL" -a "$BOOTED" = "2" ]; then
  echo -e "Bank Plan: \033[1;32mOPTIMAL \033[90m(Active=$ACTIVE Booted=$BOOTED)\033[0m"
else
  echo -e "Bank Plan: \033[0;31mSUB-OPTIMAL \033[90m(Active=$ACTIVE Booted=$BOOTED)\033[0m"
fi
unset ACTIVE ACTIVE_OPTIMAL BOOTED
echo
PROFILE
END
echo 'exit 0'
}
#endregion

#region Environment
set_defaults() {
  __BRIDGED="N"
  __BKUP=""
  __COREDUMP_REBOOT=""
  __CWMP=""
  __CWMP_DNS=""
  __HOSTNAME=""
  __IPADDR=""
  __KEYS=""
  __MOBILED=""
  __NOEXEC=""
  __ROOTPWD="root"
  __REBOOT="Y"
  __SYSLOG_IP=""
  __SYSLOG_PORT=""
  __VERBOSE="N"
  __NO_AUTH_KEYS_CHK="N"
  __NO_BANK_PLAN_CHK="N"
  __NO_FWD="N"
  __NO_LEASES="N"
  __NO_RC_LOCAL="N"
  __NO_SMSDB="N"
  __NO_ULA="N"
}

set_defaults
ABORT="N"
FIRMWARE=""
FORCE_BACKUP="N"
NO_BACKUP="N"
YES="N"
SAVE_DEFAULTS="N"
SHOW_DEFAULTS="N"
RESTORE_CONFIG="N"
RESTORE_IPADDR="N"
RESTORE_OPTIONS=""
SWITCH_BANK="N"
ULA=""
IP6ASSIGN=""
FORWARDS=""
LEASES=""

VALID_IPv4_PATTERN="([^.]|^)([0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5]).([0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5]).([0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5]).([0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])([^.]|$)"

if [ -f .defaults.$SCRIPT ]; then
  . ./.defaults.$SCRIPT
fi
#endregion Environment

#region Options
upgrade() {
  RESPONSE_CODE=$(curl -kLsI -o /dev/null -w '%{http_code}' https://raw.githubusercontent.com/seud0nym/tch-gui-unhide/master/utilities/$SCRIPT)
  if [ "$RESPONSE_CODE" = 200 ]; then
    curl -kL -o $SCRIPT https://raw.githubusercontent.com/seud0nym/tch-gui-unhide/master/utilities/$SCRIPT
    if [ $? -eq 0 ]; then
      chmod +x $SCRIPT
      echo -e "${GREEN}SUCCESS:  Downloaded $SCRIPT.${NC}"
    else
      echo -e "${RED}ERROR:    Failed to download $SCRIPT?${NC}"
    fi
  elif [ "$RESPONSE_CODE" = 404 ]; then
    echo -e "${RED}ERROR:    Not found on GitHub???${NC}"
  elif [ "$RESPONSE_CODE" = 000 ]; then
    echo -e "${RED}ERROR:    No Internet connection???${NC}"
  else
    echo -e "${RED}ERROR:    Unknown response code $RESPONSE_CODE${NC}"
  fi
  exit
}

while getopts :bBcCdD:ef:h:iI:kl:mnp:svyU-: option; do
 case "${option}" in
  -)  case "${OPTARG}" in
        safe-firmware-upgrade) SCRIPT="safe-firmware-upgrade";;
        abort)          ABORT="Y"; __VERBOSE="Y";;
        i)              RESTORE_IPADDR="Y";;
        force-backup)   FORCE_BACKUP="Y";;
        no-backup)      NO_BACKUP="Y";;
        no-defaults)    set_defaults;;
        no-bank-check)  __NO_BANK_PLAN_CHK="Y";;
        no-forwards)    __NO_FWD="Y";;
        no-keys-check)  __NO_AUTH_KEYS_CHK="Y";;
        no-leases)      __NO_LEASES="Y";;
        no-rc.local)    __NO_RC_LOCAL="Y";;
        no-sms-db)      __NO_SMSDB="Y";;
        no-ula)         __NO_ULA="Y";;
        restore-config) RESTORE_CONFIG="Y"; __BRIDGED="N"; __CWMP="Y"; __NOEXEC="Y"; __KEYS="Y"; __VERBOSE="Y"; [ -z "$__IPADDR" -o "$__IPADDR" = "DHCP" -o "$__IPADDR" = "dhcp" ] && __IPADDR="$LAN_IP_NOW"; __NO_FWD="Y"; __NO_LEASES="Y"; __NO_ULA="Y"; break;;
        save-defaults)  SAVE_DEFAULTS="Y";;
        show-defaults)  SHOW_DEFAULTS="Y";;
        *)              usage;;
      esac;;
  b)  __BKUP="Y";;
  B)  __BRIDGED="Y"; __NO_FWD="Y"; __NO_LEASES="Y"; __NO_ULA="Y";;
  c)  __CWMP="Y";;
  C)  __COREDUMP_REBOOT="N";;
  d)  echo "$__CWMP_DNS" | grep -q "\bfwstore.bdms.telstra.net\b" || __CWMP_DNS="$__CWMP_DNS fwstore.bdms.telstra.net";;
  D)  echo "$__CWMP_DNS" | grep -q "\b${OPTARG}\b" || __CWMP_DNS="$__CWMP_DNS $OPTARG";;
  e)  __NOEXEC="Y";;
  f)  if echo "$OPTARG" | grep -qE '\.(pkgtb|rbi|bin)$'; then
        FIRMWARE="${OPTARG}"
        echo "$FIRMWARE" | grep -qE '\.pkgtb$' && SWITCH_BANK="Y"
      else
        echo -e "${RED}ERROR:    Firmware file names must end with .pkgtb or .rbi or .bin!${NC}"
        exit
      fi;;
  h)  __HOSTNAME="$OPTARG";;
  i)  __IPADDR="$LAN_IP_NOW";;
  I)  if echo "${OPTARG}" | grep -qE "$VALID_IPv4_PATTERN"; then
        __IPADDR="${OPTARG}"
      elif [ "${OPTARG}" = "DHCP" -o "${OPTARG}" = "dhcp" ]; then
        __IPADDR="${OPTARG}"
      else
        echo -e "${RED}ERROR:    Invalid IP address: $OPTARG${NC}"
        exit
      fi;;
  k)  __KEYS="Y";;
  l)  if echo "${OPTARG}" | grep -q ':'; then
        __SYSLOG_IP="${OPTARG%%:*}"
        __SYSLOG_PORT="$(echo $OPTARG | cut -d: -f2)"
      else
        __SYSLOG_IP="${OPTARG}"
        __SYSLOG_PORT="514"
      fi
      if ! echo "${OPTARG}" | grep -qE "$VALID_IPv4_PATTERN"; then
        echo -e "${RED}ERROR:    Invalid IP address for syslog: $__SYSLOG_IP${NC}"
        exit
      fi;;
  m)  __MOBILED="Y";;
  n)  __REBOOT="N";;
  p)  __ROOTPWD="${OPTARG}";;
  s)  SWITCH_BANK="Y";;
  v)  __VERBOSE="Y";;
  y)  YES="Y";;
  U)  upgrade;;
  *)  usage;;
 esac
done
shift $((OPTIND-1))
#endregion Options

check_location

TARGET_BANK=/overlay/${BOOTED}
TARGET_MTD=${BOOTED}
if [ $SWITCH_BANK = "Y" ]; then
  TARGET_BANK=/overlay/${NOT_BOOTED}
  TARGET_MTD=${NOT_BOOTED}
fi

BOOTED_FW="$(uci -q get env.var.friendly_sw_version_activebank)"
if [ -n "$BOOTED_FW" ]; then
  BOOTED_SUFFIX="$(uci -q get versioncusto.override.fwversion_suffix)"
  [ -n "$BOOTED_SUFFIX" ] && BOOTED_FW="$(echo $BOOTED_FW | cut -d- -f1)$BOOTED_SUFFIX"
fi
NOT_BOOTED_FW="$(uci -q get env.var.friendly_sw_version_passivebank)"
if [ -n "$NOT_BOOTED_FW" -a -e /overlay/$NOT_BOOTED/etc/config/versioncusto ]; then
  NOT_BOOTED_SUFFIX="$(uci -c /overlay/$NOT_BOOTED/etc/config -q get versioncusto.override.fwversion_suffix)"
  [ -n "$NOT_BOOTED_SUFFIX" ] && NOT_BOOTED_FW="$(echo $NOT_BOOTED_FW | cut -d- -f1)$NOT_BOOTED_SUFFIX"
fi

show_default() {
  local _OPT="$1"
  local _TXT="$2"
  local _VAL="$3"
  local _ESC=1
  [ -z "$_VAL" -o "$_VAL" = "N" ] && _ESC=9
  if [ "$1" = "-h" ]; then
    case "$3" in
      d) _OPT="-h$VARIANT";;
      n) _OPT="-h$HOSTNAME";;
      s) _OPT="-h$VARIANT-$MAC_HEX";;
      *) _OPT="-h$3";;
    esac
  elif [ "$1" = "-n" -a "$_VAL" = "Y" ]; then
    _ESC=9
  else
    case "$1" in
      -D|-I|-l|-p) _OPT="${_OPT}${_VAL}";;
      -f) [ "$SCRIPT" = "safe-firmware-upgrade" ] && _OPT="${_VAL}" || _OPT="${_OPT}${_VAL}";;
    esac
  fi
  [ $_ESC = 1 ] && echo -en "${GREEN}"
  echo -e "OPTION:   $(printf "%-40s " "$2")\e[${_ESC}m$_OPT${NC}"
}

save_defaults() {
  set | grep '^__' > .defaults.$SCRIPT
  echo -e "\e[1;32mINFO:     Defaults saved\e[0m"
  exit
}

if [ $SAVE_DEFAULTS = "Y" -o $SHOW_DEFAULTS = "Y" -o $YES = "N" ]; then
  show_default "-b" "Backup /overlay and configuration to USB" $__BKUP
  show_default "--no-backup" "Ignore -b if backed up today" $NO_BACKUP
  show_default "--force-backup" "Force overwrite of todays backup" $FORCE_BACKUP
  show_default "-B" "Bridged mode" $__BRIDGED
  show_default "-c" "Disable CWMP during first boot" $__CWMP
  show_default "-C" "Disable reboot on core dump" $__COREDUMP_REBOOT
  show_default "-D" "DNS rewrite to stop firmware download" $__CWMP_DNS
  show_default "-e" "Disable USB 'noexec' flags" $__NOEXEC
  show_default "-f" "Firmware file to be flashed" $FIRMWARE
  show_default "-h" "Host name" $__HOSTNAME
  show_default "-I" "IP address" $__IPADDR
  show_default "-k" "Restore SSH keys" $__KEYS
  show_default "-l" "Remote syslog server" $([ -n "${__SYSLOG_IP}" ] && echo ${__SYSLOG_IP}:${__SYSLOG_PORT})
  show_default "-m" "Restore mobile operators/profiles" $__MOBILED
  show_default "-n" "Disable reboot" $__REBOOT
  show_default "-p" "Root password" $__ROOTPWD
  show_default "-s" "Switch bank" $SWITCH_BANK
  show_default "--no-bank-check"  "Disable bank plan message on login" $__NO_BANK_PLAN_CHK
  show_default "--no-forwards"    "Disable restore of port-forwards" $__NO_FWD
  show_default "--no-keys-check"  "Disable check for newer authorized_keys" $__NO_AUTH_KEYS_CHK
  show_default "--no-leases"      "Disable restore of static leases" $__NO_LEASES
  show_default "--no-rc.local"    "Disable restore of /etc/rc.local" $__NO_RC_LOCAL
  show_default "--no-sms-db"      "Disable restore of SMS messages" $__NO_SMSDB
  show_default "--no-ula"         "Disable restore of IPv6 ULA and prefix" $__NO_ULA
  show_default "--restore-config" "Restore config from USB backup" $RESTORE_CONFIG
  show_default "--i"              "Override IP in USB backup" $RESTORE_IPADDR
  [ $SHOW_DEFAULTS = "Y" ] && exit
  [ $SAVE_DEFAULTS = "Y" ] && save_defaults
fi

echo -e "${GREY}INFO:     Active partition     = $ACTIVE${NC}"
echo -e "${GREY}INFO:     Booted partition     = $BOOTED${NC}"
echo -e "${GREY}INFO:     Not Booted partition = $NOT_BOOTED${NC}"
echo -e "${GREY}INFO:     Booted firmware      = $BOOTED_FW${NC}"
echo -e "${GREY}INFO:     Not Booted firmware  = $NOT_BOOTED_FW${NC}"
echo -e "${GREY}INFO:     Target overlay bank  = $TARGET_BANK${NC}"
echo "$FIRMWARE" | grep -qE '\.(rbi|bin)$' && echo -e "${GREY}INFO:     Target MTD device    = $TARGET_MTD${NC}"
echo -e "${GREY}INFO:     /overlay filesystem  = $OVERLAY_FS${NC}"
echo -e "${GREY}INFO:     /rom filesystem      = $ROM_FS${NC}"
echo -e "${GREY}INFO:     USB symbolic link    = $USB${NC}"
echo -e "${GREY}INFO:     IPv4 Address         = $LAN_IP_NOW${NC}"

if [ -n "$__BKUP" ]; then
  if [ -z "$USB" ]; then
    echo -e "${RED}ABORTING: Backup requested, but no attached USB device found!${NC}"
    exit
  else
    TARGET="${MOUNT_PATH}${USB}/backups"
    FULL_VERSION=$(uci get version.@version[0].version | cut -d- -f1)
    if [ -s "$TARGET/$VARIANT-$SERIAL-$FULL_VERSION-overlay-files-backup.tgz" ]; then
      today="$(date +%Y-%m-%d)"
      bakdt="$(ls -l --full-time "$TARGET/$VARIANT-$SERIAL-$FULL_VERSION-overlay-files-backup.tgz" | tr -s ' ' | cut -d' ' -f6)"
      if [ "$bakdt" = "$today" -a "$FORCE_BACKUP" = "N" ]; then
        if [ "$NO_BACKUP" = "N" ]; then
          echo -e "${ORANGE}WARNING:  $TARGET/$VARIANT-$SERIAL-$FULL_VERSION-overlay-files-backup.tgz created $bakdt"
          echo -e    "${RED}ABORTING: Backup was already taken today, and ${NC}--force-backup${RED} option not specified${NC}"
          exit
        else
          __BKUP="N"
        fi
      fi
    fi
    if [ "$__BKUP" = "Y" ]; then
      echo "NOTE:     /overlay contents and current configuration will be backed up to $TARGET"
      [ -d "$TARGET" ] || mkdir -p "$TARGET"
      echo -e "${GREY}INFO:     Finding unchanged overlay contents to exclude${NC}"
      rm -f /tmp/exclude_from_overlay_backup
      echo "./$BOOTED/etc/config/env" > /tmp/exclude_from_overlay_backup
      for OVL_FILE in $(find /overlay/$BOOTED ! -type c -a ! -type d -a ! -type l | grep -v "./$BOOTED/etc/config/env" | sort); do 
        SOURCE=$(echo $OVL_FILE | sed "s|^/overlay/$BOOTED|/rom|")
        if [ -e $SOURCE ]; then
          if cmp -s $OVL_FILE $SOURCE; then # Unchanged
            echo $OVL_FILE | sed "s|^/overlay|.|" >> /tmp/exclude_from_overlay_backup
          elif echo $OVL_FILE | grep -q "^/overlay/$BOOTED/etc/config"; then
            CONFIG="$(basename $OVL_FILE)"
            TMP_CONFIG="$(mktemp)"
            uci -c /rom/etc/config show $CONFIG | sort > $TMP_CONFIG
            if ! uci show $CONFIG | grep -v $SERIAL | sort | grep -qFxvf $TMP_CONFIG; then # Only serial number changed
              echo $OVL_FILE | sed "s|^/overlay|.|" >> /tmp/exclude_from_overlay_backup
            fi
            rm -f $TMP_CONFIG
          fi
        fi
      done
      echo -e "INFO:     Backing up overlay to ${ORANGE}$VARIANT-$SERIAL-$FULL_VERSION-overlay-files-backup.tgz${NC} ..."
      tar -X /tmp/exclude_from_overlay_backup -C /overlay -czf $TARGET/$VARIANT-$SERIAL-$FULL_VERSION-overlay-files-backup.tgz $(cd /overlay && ls -d ./bank_[12])
      rm -f /tmp/exclude_from_overlay_backup
      echo -e "INFO:     Backing up config to  ${ORANGE}$VARIANT-$SERIAL-$FULL_VERSION-config.gz${NC} ..."
      uci show 2>/dev/null | awk -e "$(lua -e 'proxy=require("datamodel");
      passwords=proxy.get("rpc.gui.pwd.")
      if passwords then
        for _,v in ipairs(passwords) do
          profile=string.match(v.path,"rpc%.gui%.pwd%.@([^%.]*)%.")
          print(string.format("/^mmpbxrvsipnet.%s.password=/{print \"mmpbxrvsipnet.%s.password=\\\"%s\\\"\";next;}",profile,profile,v.value))
        end
      end
      print("1")')" | gzip > $TARGET/$VARIANT-$SERIAL-$FULL_VERSION-config.gz
    fi
  fi
fi

if [ $RESTORE_CONFIG = Y ]; then
  __BRIDGED="N"
  if [ -z "$USB" ]; then
    echo -e "${RED}ABORTING: Configuration restore requested, but no attached USB device found!${NC}"
    exit
  else
    if [ -z "$1" ]; then
      RESTORE_OPTIONS=$(ls ${MOUNT_PATH}${USB}/backups/$VARIANT-$SERIAL-*-overlay-files-backup.tgz 2>/dev/null | sort -r | head -n 1)
      if [ -z "$RESTORE_OPTIONS" ]; then
        echo -e "${RED}ABORTING: Configuration restore requested, but no overlay backups for serial number $SERIAL found!${NC}"
        exit
      fi
    elif [ ! -e "$1" ]; then
      echo -e "${RED}ABORTING: Configuration restore requested, but $1 does not exist!${NC}"
    else
      RESTORE_OPTIONS="$(cd $(dirname $1);pwd)/$(basename $1)"
    fi
    if ! echo "$RESTORE_OPTIONS" | grep -q 'overlay-files-backup.tgz$'; then
      echo -e "${RED}ABORTING: Configuration restore requested, but $1 is not an overlay files backup!${NC}"
      exit
    fi
    if [ ! -e "${RESTORE_OPTIONS%-overlay-files-backup.tgz}-config.gz" ]; then
      echo -e "${RED}ABORTING: $RESTORE_OPTIONS found, but ${RESTORE_OPTIONS%-overlay-files-backup.tgz}-config.gz does not exist!${NC}"
    fi
    if [ -z "$FIRMWARE" ]; then
      DEVICE_VERSION="$VERSION"
    else
      DEVICE_VERSION=$(echo $FIRMWARE | grep -o '[1-2][0178]\.[0-9]\(.c\)*')
      if [ -z "$DEVICE_VERSION" ]; then
        echo -e "${RED}ABORTING: Unable to determine firmware version from filename: $FIRMWARE${NC}"
        echo -e "${RED}          Cannot determine if configuration restore is possible!${NC}"
        exit
      fi
    fi
    DEVICE_VERSION_NUMBER="$(comparable_version $DEVICE_VERSION)"
    BACKUP_VERSION="$(gzip -cdk "${RESTORE_OPTIONS%-overlay-files-backup.tgz}-config.gz" | grep env.var.friendly_sw_version_activebank | cut -d"'" -f2 | cut -d- -f1 | sed -e 's/\.[0-9][0-9][0-9][0-9]$//')"
    BACKUP_VERSION_NUMBER="$(comparable_version $BACKUP_VERSION)"
    if [ "$VERSION" = "$BACKUP_VERSION" -o \( "$DEVICE_VERSION_NUMBER" -le 2004000 -a "$BACKUP_VERSION_NUMBER" -le 2004000 \) -o \( "$DEVICE_VERSION_NUMBER" -ge 2004000 -a "$BACKUP_VERSION_NUMBER" -ge 2004000 \) ]; then
      OVERLAY_BACKUP="$(basename $RESTORE_OPTIONS | cut -d- -f1-3) ($(ls -l $RESTORE_OPTIONS | tr -s ' ' | cut -d' ' -f6-8))"
      if [ "$RESTORE_IPADDR" = "Y" ]; then
        if [ "$__IPADDR" = "DHCP" -o "$__IPADDR" = "dhcp" ]; then
          echo -e "${RED}ABORTING: Cannot configure IP from DHCP with --restore-config !${NC}"
          exit
        fi
        RESTORE_OPTIONS="-i $__IPADDR $RESTORE_OPTIONS"
      fi
      RESPONSE_CODE=$(curl -kLsI -m 5 -o /dev/null -w '%{http_code}' https://raw.githubusercontent.com/seud0nym/tch-gui-unhide/master/utilities/restore-config/.sha256)
      if [ "$RESPONSE_CODE" != 200 ]; then
        case "$RESPONSE_CODE" in
          404) echo -e "${RED}ERROR:    https://raw.githubusercontent.com/seud0nym/tch-gui-unhide/master/utilities/restore-config/.sha256 NOT FOUND???${NC}";;
          000) echo -e "${RED}ERROR:    No Internet connection???${NC}";;
          *)   echo -e "${RED}ERROR:    Unknown response code $RESPONSE_CODE when checking Internet connectivity???${NC}";;
        esac
        echo -e "${RED}ABORTING: Configuration restore would fail!${NC}"
        exit
      fi
    else
      echo -e "${RED}ABORTING: Unable to restore configuration from $BACKUP_VERSION to $DEVICE_VERSION!${NC}"
      exit
    fi
  fi
fi
# region restore-config.sh
[ $RESTORE_CONFIG = Y -a ! -e $TARGET/restore-config.sh ] && cat <<"EoSH" > $TARGET/restore-config.sh
#!/bin/sh

SCRIPT="$(basename $0)"
DIR="$(cd $(dirname $0); pwd)/restore-config"

log() {
  local flag="$1"
  local colour level
  shift
  case "$flag" in
    D|V)  colour="\033[90m";   level="DEBUG:";;
    E)    colour="\033[0;31m"; level="ERROR:";;
    I)    colour="\033[1;32m"; level="INFO: ";;
    W)    colour="\033[1;32m"; level="WARN: ";;
  esac
  echo -e "${level}  ${colour}$*\033[0m"
}

download() {
  local SOURCE="$1"
  local TARGET="$(basename $1)"
  local FOLDER="$2"
  RESPONSE_CODE=$(curl -kLsI -o /dev/null -w '%{http_code}' $SOURCE)
  if [ "$RESPONSE_CODE" = 200 ]; then
    log D "Downloading ${SOURCE}"
    mkdir -p $FOLDER
    curl -kLs $SOURCE -o $FOLDER/$TARGET
  else
    case "$RESPONSE_CODE" in
      404)  log E "$SOURCE was not found???";;
      000)  log E "Failed to download $SOURCE - No Internet connection???";;
      *)    log E "Failed to download $SOURCE - Unknown response code $RESPONSE_CODE";;
    esac
    unlock normally
  fi
}

unlock() { 
  if [ "$1" != "normally" ]; then
    echo
    log W "Ctrl-C caught...performing clean up"
  fi

  log I "Releasing lock on $LOCK..."
  lock -u $LOCK
  [ -f $LOCK ] && rm $LOCK

  [ "$1" != "normally" ] && exit 2
}

LOCK="/var/run/${SCRIPT}.lck"
if [ -e $LOCK ]; then
  if ps | grep -qE "\b$(cat $LOCK)\b.*$SCRIPT"; then
    log E "Restore already running (PID=$(cat $LOCK))"
    exit 2
  else
    lock -u $LOCK
    rm $LOCK
  fi
fi
log I "Attempting to acquire lock on $LOCK..."
lock $LOCK
trap "unlock" 2

log I "Checking scripts..."
download https://raw.githubusercontent.com/seud0nym/tch-gui-unhide/master/utilities/restore-config/.sha256 ${DIR}
cat "${DIR}/.sha256" | while read -r sha256 file; do
  if [ ! -e "${DIR}/${file}" -o "$sha256" != "$(sha256sum "${DIR}/${file}" 2>/dev/null | cut -d' ' -f1)" ]; then
    download https://raw.githubusercontent.com/seud0nym/tch-gui-unhide/master/utilities/restore-config/$file ${DIR}
  fi
done
rm -f "${DIR}/.sha256"

unlock normally

sh "${DIR}/000-core.sh" $*
EoSH
[ -e $TARGET/restore-config.sh ] && chmod +x $TARGET/restore-config.sh
# endregion restore-config.sh

RBI="Y"
if [ -n "$FIRMWARE" ]; then
  if [ -e "$FIRMWARE" ]; then
    if echo "$FIRMWARE" | grep -qE '\.pkgtb$'; then
      echo -e "NOTE:     ${GREEN}$(basename $FIRMWARE)${NC} will be flashed into ${GREEN}$NOT_BOOTED${NC} by sysupgrade${NC}"
      RBI="N"
    else
      if echo "$FIRMWARE" | grep -qE '\.rbi$'; then
        if [ -z "$USB" ]; then
          echo -e "WARNING:  ${ORANGE}$(basename $FIRMWARE) will be unpacked to /tmp before flashing.${NC}"
          echo -e "          ${RED}THIS IS NOT RECOMMENDED!${NC} You should use a USB stick."
          echo -e "          Do you have enough RAM? If you don't, unpacking will ${RED}FAIL!${NC}"
        else
          echo -e "NOTE:     ${ORANGE}$(basename $FIRMWARE)${NC} will be unpacked to ${MOUNT_PATH}${USB} before flashing.${NC}"
          echo "          Do you have enough space?"
        fi
        echo -e "NOTE:     ${GREEN}$(basename $FIRMWARE .rbi).bin${NC} will be flashed into ${GREEN}$TARGET_MTD${NC} by direct mtd write"
      else # .bin
        echo -e "NOTE:     ${GREEN}$(basename $FIRMWARE)${NC} will be flashed into ${GREEN}$TARGET_MTD${NC} by direct mtd write"
      fi
      if [ "$ACTIVE" = "$BOOTED" ]; then
        echo -e "${RED}WARNING:  Bank plan is NOT optimal! Active bank is $ACTIVE and booted bank is $BOOTED!${NC}"
        echo -e "${ORANGE}          Are you REALLY, REALLY sure you wish to proceed?"
      fi
    fi
  else
    echo -e "${RED}ABORTING: $FIRMWARE does not exist!${NC}"
    exit 2
  fi
  echo -e "NOTE:     ${ORANGE}Services will be stopped to increase free RAM${NC}"
fi

if [ $RESTORE_CONFIG = Y ]; then
  echo -e "NOTE:     Configuration backup ${GREEN}${OVERLAY_BACKUP}${NC} will be restored to the device!"
  echo -e "${ORANGE}WARNING:  Configuration restore can take 5-10 minutes. Be patient!${NC}"
  echo -e "${ORANGE}WARNING:  The device MUST have internet access after factory reset or the configuration restore will ${RED}FAIL!${NC}"
  echo "COMMAND:  ${MOUNT_PATH}${USB}/backups/restore-config ${RESTORE_OPTIONS}"
  RESTORE_CFG="(while [ ! -e ${MOUNT_PATH}${USB} ]; do sleep 2; done; sh ${MOUNT_PATH}${USB}/backups/restore-config.sh -vvy $RESTORE_OPTIONS 2>&1 | logger -t restore-config) &"
else
  echo -e "${ORANGE}WARNING:  You are resetting to factory defaults!${NC}"
  echo -e "${ORANGE}          Any customisation or settings you have changed will be lost!${NC}"
  grep -q 'tch-gui-unhide' /www/docroot/gateway.lp && echo -e "NOTE:     You will need to ${ORANGE}re-run tch-gui-unhide${NC} after rebooting!"
fi

if [ "$__BRIDGED" = "Y" ]; then
  echo -e "${ORANGE}WARNING${NC}:  Device will be in ${ORANGE}BRIDGED${NC} mode after rebooting!"
  BRIDGE_CFG="uci set wansensing.global.enable='0'"
  BRIDGE_CFG="$BRIDGE_CFG"$'\n'"uci set network.lan.ifname='eth0 eth1 eth2 eth3 eth4 atm_8_35 ptm0'"
  BRIDGE_CFG="$BRIDGE_CFG"$'\n'"uci set network.config='config'"
  BRIDGE_CFG="$BRIDGE_CFG"$'\n'"uci set network.config.wan_mode='bridge'"
  BRIDGE_CFG="$BRIDGE_CFG"$'\n'"uci set dhcp.lan.ignore='1'"
  BRIDGE_CFG="$BRIDGE_CFG"$'\n'"uci set network.wan.ifname='lo'"
  BRIDGE_CFG="$BRIDGE_CFG"$'\n'"uci set network.wan.auto='0'"
  BRIDGE_CFG="$BRIDGE_CFG"$'\n'"uci set network.wan.proto='none'"
  for ifname in $(grep -rhE "uci *set *network\.(ppp|ipoe|wan|eth4|atm_8_35|ptm0).*=interface" /rom/etc/uci-defaults/ | cut -d. -f2 | cut -d= -f1); do
    [ "$ifname" != "wan" ] && BRIDGE_CFG="$BRIDGE_CFG"$'\n'"uci delete network.$ifname"
  done
fi

echo -e "NOTE:     Root access will be preserved and the root password will be set to '${GREEN}${__ROOTPWD}${NC}'"

NOW_C_CLASS="$(echo $LAN_IP_NOW | cut -d. -f1-3)"
NOW_C_CLASS_ESCAPED="$(echo $NOW_C_CLASS | sed -e 's/\./\\./g')"

if [ "$__IPADDR" = "DHCP" -o "$__IPADDR" = "dhcp" ]; then
  echo -e "NOTE:     IP address will be set via ${GREEN}DHCP${NC}"
  LAN_CFG="uci set network.lan.proto='dhcp'"
elif [ -n "$__IPADDR" ]; then
  CFG_C_CLASS="$(echo $__IPADDR | cut -d. -f1-3)"
  for GUESTIP in $(uci show network | grep "network\.Guest.*ipaddr=" | cut -d"'" -f2 | cut -d. -f1-3 | sort -u);do
    if [ "$CFG_C_CLASS" = "$GUESTIP" ]; then
      echo -e "${RED}ABORTING: $__IPADDR conflicts with the Guest IP address range!${NC}"
      exit
    fi
  done
  echo -e "NOTE:     IP address will be set to '${GREEN}$__IPADDR${NC}'"
  LAN_CFG="uci set network.lan.ipaddr='$__IPADDR'"
  if [ $RESTORE_CONFIG = N ]; then
    if [ $__NO_ULA = N ]; then
      IP6ASSIGN="$(uci -q get network.lan.ip6assign)"
      if [ -n "$IP6ASSIGN" ]; then
        echo -e "NOTE:     LAN IPv6 prefix size will be set to '${GREEN}/$IP6ASSIGN${NC}'"
        LAN_CFG="$LAN_CFG"$'\n'"uci set network.lan.ip6assign='$IP6ASSIGN'"
      fi
      ULA="$(uci -q get network.globals.ula_prefix)"
      if [ -n "$ULA" ]; then
        echo -e "NOTE:     IPv6 ULA address will be set to '${GREEN}$ULA${NC}'"
        LAN_CFG="$LAN_CFG"$'\n'"uci set network.globals.ula_prefix='$ULA'"
      fi
    fi
    if [ $__NO_LEASES = N ]; then
      LEASES="$(uci show dhcp | awk -F= -e '$1~/^dhcp\.[^.]*$/ && $2!~/^host$/{KEY="";} /=host$/{print "uci set " $0;KEY=$1;next;} {if(KEY!="" && index($0,KEY)!=0) print "uci set " $0;}0')"
      if [ -n "$LEASES" ]; then
        if [ "$NOW_C_CLASS" = "$CFG_C_CLASS" ]; then
          echo -e "NOTE:     Static leases will be ${GREEN}restored${NC}"
        else
          echo -e "NOTE:     Static leases will be ${GREEN}restored${NC} with new class C range '${GREEN}${CFG_C_CLASS}${NC}'"
          LEASES="$(echo "$LEASES" | sed -e "s/$NOW_C_CLASS_ESCAPED/$CFG_C_CLASS/")"
        fi
        TAGS="$(uci show dhcp | awk -F= -e '$1~/^dhcp\.[^.]*$/ && $2!~/^tag$/{KEY="";} /=tag$/{print "uci set " $0;KEY=$1;next;} /dhcp_option=/{if(KEY!="" && index($0,KEY)!=0) print "uci add_list " $0;next;} {if(KEY!="" && index($0,KEY)!=0) print "uci set " $0;}0')"
        [ -n "$TAGS" ] && LAN_CFG="$LAN_CFG"$'\n'"$TAGS"
        LAN_CFG="$LAN_CFG"$'\n'"$LEASES"
      fi
      if [ -n "$(uci -q show user_friendly_name)" ]; then
        UFN="echo '$(cat /etc/config/user_friendly_name | gzip | base64 | tr -d "$IFS")' | base64 -d | gunzip > /etc/config/user_friendly_name"
        echo -e "NOTE:     User Friendly Names will be '${GREEN}restored${NC}'"
        LAN_CFG="$LAN_CFG"$'\n'"$UFN"
      fi
    fi
    if [ $__NO_FWD = N ]; then
      FORWARDS="$(uci show firewall | awk -F= -e '$1~/^firewall\.[^.]*$/ && $2!~/^(userredirect|pinholerule)$/{KEY="";} /=(userredirect|pinholerule)$/{print "uci set " $0;KEY=$1;next;} /proto=/{if(KEY!="" && index($1,KEY)!=0) print "uci add_list " $0;next;} $0!~/_key/{if(KEY!="" && index($0,KEY)!=0) print "uci set " $0;}0')"
      if [ -n "$FORWARDS" ]; then
        if [ "$NOW_C_CLASS" = "$CFG_C_CLASS" ]; then
          echo -e "NOTE:     Port forwarding rules will be '${GREEN}restored${NC}'"
        else
          echo -e "NOTE:     Port forwarding rules will be '${GREEN}restored${NC}' with new class C range '${GREEN}${CFG_C_CLASS}${NC}'"
          FORWARDS="$(echo "$FORWARDS" | sed -e "s/$NOW_C_CLASS_ESCAPED/$CFG_C_CLASS/")"
        fi
        LAN_CFG="$LAN_CFG"$'\n'"$FORWARDS"
      fi
    fi
  fi
fi

if [ -n "$__CWMP" ]; then
  echo -e "NOTE:     CWMP will be ${ORANGE}stopped${NC} during the reboot"
  CWMP_CFG="uci set cwmpd.cwmpd_config.state='0'"$'\n'"/etc/init.d/cwmpd disable"
elif [ -z "$__CWMP_DNS" ]; then
  echo -e "${ORANGE}WARNING:  CWMP firmware upgrades will be ${RED}ACTIVE${ORANGE} after reboot!${NC}"
fi

if [ -n "$__COREDUMP_REBOOT" ]; then
  echo -e "NOTE:     Reboot on core dump will be ${GREEN}disabled${NC}"
  SYS_CFG="uci set system.@coredump[0].reboot='0'"
fi

if [ -n "$__CWMP_DNS" ]; then
  for domain in $__CWMP_DNS; do
    echo -e "NOTE:     DNS will be configured to ${ORANGE}disable${NC} CWMP firmware downloads from ${GREEN}${domain}${NC}"
    [ -n "$DNSMASQ_CFG" ] && DNSMASQ_CFG="${DNSMASQ_CFG}"$'\n'
    DNSMASQ_CFG="${DNSMASQ_CFG}uci add_list dhcp.main.address='/$domain/0.0.0.0'"$'\n'"uci add_list dhcp.main.address='/$domain/::'"
  done
fi

if [ -n "$__HOSTNAME" ]; then
  case "${__HOSTNAME}" in
    d)  __HOSTNAME="$VARIANT";;
    n)  __HOSTNAME="$HOSTNAME";;
    s)  __HOSTNAME="$VARIANT-$MAC_HEX";;
  esac
  echo -e "NOTE:     Host name will be set to ${GREEN}${__HOSTNAME}${NC}"
  HOSTNAME_CFG="uci delete dhcp.main.hostname"$'\n'"uci add_list dhcp.main.hostname='$__HOSTNAME'"$'\n'"uci set system.@system[0].hostname='$__HOSTNAME'"
fi

if [ -n "$__NOEXEC" ]; then
  echo -e "NOTE:     Any 'noexec' flags will be ${ORANGE}removed${NC} from USB filesystem mounts"
  NOEXEC_CFG="sed -e 's/noexec,//' -e 's/,noexec//' -i /etc/config/mountd"
elif [ "${VERSION%%.*}" -ge 20 ]; then
  echo -e "${ORANGE}WARNING:  'noexec' flags will ${RED}NOT${ORANGE} be removed from USB filesystem mounts!${NC}"
fi

if [ -n "$__KEYS" ]; then
  rm -rf /tmp/rtfdwr_keys
  mkdir -p /tmp/rtfdwr_keys/etc/dropbear
  cp -p /etc/dropbear/* /tmp/rtfdwr_keys/etc/dropbear/
  rm -f /tmp/rtfdwr_keys/etc/dropbear/authorized_keys_closed
  if [ "$__NO_AUTH_KEYS_CHK" = "N" -a -e authorized_keys ] && cmp -s /rom/etc/dropbear/authorized_keys /etc/dropbear/authorized_keys; then
    echo -e "NOTE:     /etc/dropbear/authorized_keys will be ${GREEN}replaced${NC}"
    cp authorized_keys /tmp/rtfdwr_keys/etc/dropbear/authorized_keys
    chmod 600 /tmp/rtfdwr_keys/etc/dropbear/authorized_keys
    chown root:root /tmp/rtfdwr_keys/etc/dropbear/authorized_keys
  fi
  SSH_DIRS="etc/dropbear"
  if [ -d /root/.ssh ]; then
    mkdir -p /tmp/rtfdwr_keys/root/.ssh
    cp -p /root/.ssh/* /tmp/rtfdwr_keys/root/.ssh/
    SSH_DIRS="${SSH_DIRS} root/.ssh"
  fi
  echo -e "NOTE:     SSH keys will be ${GREEN}restored${NC}: ${GREEN}$(find /tmp/rtfdwr_keys -type f -exec basename {} \; | sort | xargs)${NC}"
  KEYS_CFG="echo '$(tar -czf - -C /tmp/rtfdwr_keys $SSH_DIRS | base64 | tr -d "$IFS")' | base64 -d | tar -xzvf - -C /"
else
  echo -e "${ORANGE}WARNING:  SSH keys will ${RED}NOT${ORANGE} be restored!${NC}"
fi

if uci -q get mobiled.@profile[0] > /dev/null; then
  if [ -n "$__MOBILED" ]; then
    echo -e "NOTE:     Mobile profiles and operators will be ${GREEN}restored${NC}"
    MOBILED_CFG="while uci -q get mobiled.@profile[0]; do uci delete mobiled.@profile[0]; done"$'\n'"while uci -q get mobiled.@operator[0]; do uci delete mobiled.@operator[0]; done"
    MOBILED_CFG="$MOBILED_CFG"$'\n'"$(uci show mobiled|grep @profile|sed -e 's|^\([^[]*\)\[[0-9]*\]=profile|uci add mobiled profile|' -e 's/^\([^[]*\)\[[0-9]*\]/uci set \1[-1]/')"
    MOBILED_CFG="$MOBILED_CFG"$'\n'"uci set network.wwan.profile='$(uci -q get network.wwan.profile)'"
    MOBILED_CFG="$MOBILED_CFG"$'\n'"$(uci show mobiled|grep @operator|sed -e 's|^\([^[]*\)\[[0-9]*\]=operator|uci add mobiled operator|' -e 's/^\([^[]*\)\[[0-9]*\]/uci set \1[-1]/')"
    MOBILED_CFG="$MOBILED_CFG"$'\n'"uci set mobiled.@device[0].mcc='$(uci -q get mobiled.@device[0].mcc)'"
    MOBILED_CFG="$MOBILED_CFG"$'\n'"uci set mobiled.@device[0].mnc='$(uci -q get mobiled.@device[0].mnc)'"
  else
    echo -e "${ORANGE}WARNING:  Mobile profiles and operators will ${RED}NOT${ORANGE} be restored!${NC}"
  fi
fi

if ! cmp -s /rom/etc/rc.local /etc/rc.local; then
  if [ "$__NO_RC_LOCAL" = "N" ]; then
    echo -e "NOTE:     /etc/rc.local will be ${GREEN}restored${NC}"
    RC_LOCAL_CFG="echo '$(tar -czf - -C / etc/rc.local | base64 | tr -d "$IFS")' | base64 -d | tar -xzvf - -C /"
  else
    echo -e "${ORANGE}WARNING:  /etc/rc.local will ${RED}NOT${ORANGE} be restored!${NC}"
  fi
fi

if [ -e /etc/sms.db ]; then
  if [ "$__NO_SMSDB" = "N" ]; then
    echo -e "NOTE:     SMS messages database will be ${GREEN}restored${NC}"
    SMSDB_CFG="echo '$(tar -czf - -C / etc/sms.db | base64 | tr -d "$IFS")' | base64 -d | tar -xzvf - -C /"
  else
    echo -e "${ORANGE}WARNING:  SMS messages database will ${RED}NOT${ORANGE} be restored!${NC}"
  fi
fi

if [ -n "$__SYSLOG_IP" ]; then
  echo -e "NOTE:     Log messages will be sent to remote syslog server at ${GREEN}$__SYSLOG_IP${NC} (Port ${GREEN}$__SYSLOG_PORT${NC}) after reset${NC}"
  SYSLOG_CFG="uci set system.@system[0].log_ip='$__SYSLOG_IP'"$'\n'"uci set system.@system[0].log_port='$__SYSLOG_PORT'"
fi

[ $SWITCH_BANK = Y ] && echo -e "NOTE:     The active bank will be switched to ${GREEN}bank_$PASSIVE${NC}"

if [ "$__REBOOT" = "Y" ]; then
  if [ $RESTORE_CONFIG = Y ]; then
    echo -e "${ORANGE}WARNING:  The device will reboot ${GREEN}TWICE${ORANGE} to apply the restored configuration!${NC}"
  elif [ -e /proc/sysrq-trigger ]; then
    echo -e "${ORANGE}WARNING:  The device will be rebooted using SysRQ trigger!${NC}"
  else
    echo -e "${ORANGE}WARNING:  The device will be rebooted using the system reboot command!${NC}"
  fi
else
  echo -e "${ORANGE}WARNING:  The device will ${GREEN}NOT REBOOT${ORANGE}!${NC}"
fi

if [ $__VERBOSE = Y ]; then
  echo -e "NOTE:     The following reset script will executed after reboot:${GREY}"
  rtfd_script
  echo -en "${NC}"
fi

if [ $ABORT = Y ]; then
  echo -e "NOTE:     Aborted at user request"
  exit
elif [ $YES = N ]; then
  echo -en "${GREEN}ACTION:   Enter [y] to continue, [s] to save options as defaults, or anything else to exit now${NC} "
  read
  [ "$REPLY" = "s" ] && save_defaults
  [ "$REPLY" != "y" -a "$REPLY" != "Y" ] && exit
fi

if [ -z "$__CWMP" -a -z "$__CWMP_DNS" ]; then
  echo -e "${ORANGE}"
  echo '**************************************************************************'
  echo '* !! WARNING !!                                                          *'
  echo '*                                                                        *'
  echo '* You are about to reset without specifying either the -c or -d options! *'
  echo '*                                                                        *'
  echo '* If you have an internet connection after reboot (either a fixed wired  *'
  echo '* connection or 4G backup connection via a SIM card) your device will be *'
  echo '* vulnerable to an over-the-air firmware update and you could lose root! *'
  echo '*                                                                        *'
  echo '* You need to re-confirm that you understand this and want to continue.  *'
  echo '**************************************************************************'
  echo
  echo -en "ACTION:   Enter y to continue, or anything else to exit now${NC} "
  read
  if [ "$REPLY" != "y" -a "$REPLY" != "Y" ]; then
    exit
  fi
fi

if echo "$FIRMWARE" | grep -qE '\.rbi$'; then
  if [ -z "$USB" ]; then
    target="/tmp/$(basename $FIRMWARE .rbi).bin"
  else
    target="${MOUNT_PATH}${USB}/$(basename $FIRMWARE .rbi).bin"
  fi
  echo -e "INFO:     About to unpack ${ORANGE}$FIRMWARE${NC} to ${ORANGE}$target${NC}"
  echo -n -e "${GREEN}ACTION:   Enter y to continue, or anything else to abort: ${NC}"
  read CONFIRM

  if [ "$CONFIRM" = "y" -o "$CONFIRM" = "Y" ]; then
    if [ -f "$target" ]; then
      echo -e "$INFO:     Removing existing ${ORANGE}$target${NC} before extracting ${ORANGE}$FIRMWARE${NC}"
      rm $target
    fi
    cat "$FIRMWARE" | (bli_parser && echo -e "INFO:     Unpacking ${ORANGE}$FIRMWARE${NC}. Please wait... (This will take a while)" && (bli_unseal | dd bs=4 skip=1 seek=1 of="$target"))
    srce_size=$(du "$FIRMWARE" | cut -f1)
    dest_size=$(du "$target" | cut -f1)
    if [ $dest_size -le $srce_size ]; then
      echo -e "${RED}ERROR:    Unpack failed? $FIRMWARE is ${srce_size}Kb. $target should be larger but is ${dest_size}Kb!${NC}"
      rm "$target"
      exit 1
    fi
    FIRMWARE="$target"
  else
    exit
  fi
fi

echo -e  "INFO:     $(grep '^Mem\(Free\|Available\)' /proc/meminfo | xargs)"
sp='/-\|'; i=1

if [ -n "$LSOF" ]; then
  for pid in $(pgrep flock); do
    fd=$(sed -e 's/^.*flock//' /proc/$pid/cmdline | tr '\0' ' ' | xargs)
    if [ -n "$fd" ]; then
      if echo -n "$fd" | grep -E '[0-9]*'; then
        lockfile=$(readlink /proc/$pid/fd/$fd)
      else
        lockfile="$fd"
      fi
      ppid=$(grep -i ^PPId /proc/$pid/status | cut -d: -f2 | xargs)
      service=$(basename $(grep -oE '/etc/init.d/[^\0]*' /proc/$ppid/cmdline) 2>/dev/null)
      if [ -n "$service" ]; then
        if [ -e "$lockfile" ]; then
          pids=$($LSOF $lockfile | grep $lockfile | grep -v "\b$pid\b\|\b$ppid\b" | tr -s ' ' | cut -d' ' -f2 | xargs echo $pid $ppid)
        else
          pids="$pid $ppid"
        fi
        echo -en "\033[2K\rINFO:     Clearing file lock on $service service ${GREY}($lockfile)${NC}"
        rm $lockfile 1>/dev/null 2>&1
        for p in $pids; do
          kill -9 $pids 1>/dev/null 2>&1
        done
      fi
    fi
  done
  echo -e "\033[2K\rINFO:     Cleared service file locks${NC}"
fi

for service in $(ls /etc/rc.d/K* | grep -v 'dropbear\|network\|umount'); do
  exe=$(basename $(readlink $service) 2>/dev/null)
  echo -en "\033[2K\rINFO:     Stopping services: $(echo $sp | cut -c $i) ${GREY}$exe${NC}"
  [ "$exe" = "cwmpd" ] && kill -9 $(pgrep cwmpd) 1>/dev/null 2>&1
  $service stop 1>/dev/null 2>&1
  [ $i -lt 4 ] && i=$(( $i + 1 )) || i=1
done
echo -e "\033[2K\rINFO:     Stopped services"

if [ -n "$LSOF" ]; then
  $LSOF /overlay | awk '/ REG /{print $2}' | uniq | while read p; do
    if [ -d "/proc/$p" ]; then
      exe=$(readlink /proc/$p/exe)
      echo -en "\033[2K\rINFO:     Killing writing processes: $(echo $sp | cut -c $i) ${GREY}$exe ($p)${NC}"
      kill -9 $p
      [ $i -lt 4 ] && i=$(( $i + 1 )) || i=1
    fi
  done
  echo -e "\033[2K\rINFO:     Killed writing processes"
fi

echo -e  "INFO:     $(grep '^Mem\(Free\|Available\)' /proc/meminfo | xargs)"

if [ -n "$FIRMWARE" -a "$RBI" = "N" ]; then
  TARGET_BANK=/overlay/${NOT_BOOTED}
  echo -e "INFO:     Writing ${ORANGE}$FIRMWARE${NC} into ${ORANGE}${NOT_BOOTED}${NC}..."
  echo -en "${GREY}"
  sysupgrade -n -v --no-reboot "$FIRMWARE"
  VERIFY_RESULT=$?
  echo -en "${NC}"
  rm -f /overlay/data.remove_due_to_upgrade /overlay/sysupgrade.bank.switchover
  [ -d ${TARGET_BANK}.remove_due_to_upgrade ] && mv ${TARGET_BANK}.remove_due_to_upgrade $TARGET_BANK
  if [ "$VERIFY_RESULT" -ne 0 ]; then
    echo -e "${RED}ABORTING: sysupgrade FAILED!!${NC}"
    exit 2
  fi
fi

echo -e "${ORANGE}INFO:     Resetting...${NC}"
# https://hack-technicolor.readthedocs.io/en/stable/Upgrade/#clean-up
echo -e "${GREY}INFO:     Deleting ${TARGET_BANK}...${NC}"
rm -rf $TARGET_BANK
echo -e "${GREY}INFO:     Creating ${TARGET_BANK}/etc/uci-defaults/${UCI_DEFAULTS}...${NC}"
mkdir -p ${TARGET_BANK}/etc/uci-defaults
chmod 755 ${TARGET_BANK} ${TARGET_BANK}/etc ${TARGET_BANK}/etc/uci-defaults
rtfd_script > ${TARGET_BANK}/etc/uci-defaults/${UCI_DEFAULTS}
chmod +x ${TARGET_BANK}/etc/uci-defaults/${UCI_DEFAULTS}
sync
echo -e "${GREEN}INFO:     Device has been reset to factory defaults and root access retained${NC}"

if [ -n "$FIRMWARE" -a "$RBI" = "Y" ]; then
  cp $(which mtd) $(which grep) /tmp/
  echo -e "INFO:     Writing ${ORANGE}$FIRMWARE${NC} into ${ORANGE}${TARGET_MTD}${NC}..."
  echo -en "${GREY}"
  /tmp/mtd -e ${TARGET_MTD} write "$FIRMWARE" ${TARGET_MTD}
  echo -en "${NC}"
  echo -e "INFO:     Verifying ${ORANGE}${TARGET_MTD}${NC} against ${ORANGE}$FIRMWARE${NC}..."
  VERIFY_RESULT=$(/tmp/mtd verify "$FIRMWARE" ${TARGET_MTD} 2>&1)
  echo -e "${GREY}$VERIFY_RESULT${NC}"
  if ! echo "$VERIFY_RESULT" | /tmp/grep -q 'Success'; then
    echo -e "${RED}ABORTING: mtd verify FAILED!!${NC}"
    exit 2
  fi
fi

if [ $SWITCH_BANK = "Y" ]; then
  echo -e "INFO:     Switching active bank to ${GREEN}bank_$PASSIVE${NC}"
  if [ -z "$BOOTMGR" ]; then
    echo bank_$PASSIVE > /proc/banktable/active
  elif [ -z "$FIRMWARE" ]; then
    $BOOTMGR switch_over $PASSIVE
  fi
fi

if [ "$__REBOOT" = "Y" ]; then
  echo -e "${ORANGE}INFO:     Rebooting...${NC}"
  if [ -e /proc/sysrq-trigger ]; then
    sleep 1
    echo 1 > /proc/sys/kernel/sysrq
    echo b > /proc/sysrq-trigger
  else
    reboot
  fi
  sleep 10
else
  echo -e "${ORANGE}ACTION:   You should power cycle the device now!${NC}"
  echo -e "${GREEN}INFO:     Done!${NC}"
fi
